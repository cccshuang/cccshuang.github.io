<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>shuang&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-09-13T08:03:35.111Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>cccshuang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Planar data classification with one hidden layer</title>
    <link href="http://yoursite.com/2018/09/06/%E2%80%98-Planar-data-classification-with-one-hidden-layerr/"/>
    <id>http://yoursite.com/2018/09/06/‘-Planar-data-classification-with-one-hidden-layerr/</id>
    <published>2018-09-06T07:50:04.000Z</published>
    <updated>2018-09-13T08:03:35.111Z</updated>
    
    <content type="html"><![CDATA[<p>np.meshgrid()<br>从坐标向量返回坐标矩阵，生成网格数据。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">x = np.arange(-2,2)</span><br><span class="line">y = np.arange(0,3)#生成一位数组，其实也就是向量</span><br><span class="line"></span><br><span class="line">x</span><br><span class="line">Out[31]: array([-2, -1,  0,  1])</span><br><span class="line"></span><br><span class="line">y</span><br><span class="line">Out[32]: array([0, 1, 2])</span><br><span class="line"></span><br><span class="line">z,s = np.meshgrid(x,y)#将两个一维数组变为二维矩阵</span><br><span class="line"></span><br><span class="line">z</span><br><span class="line">Out[36]: </span><br><span class="line">array([[-2, -1,  0,  1],</span><br><span class="line">       [-2, -1,  0,  1],</span><br><span class="line">       [-2, -1,  0,  1]])</span><br><span class="line"></span><br><span class="line">s</span><br><span class="line">Out[37]: </span><br><span class="line">array([[0, 0, 0, 0],</span><br><span class="line">       [1, 1, 1, 1],</span><br><span class="line">       [2, 2, 2, 2]])</span><br></pre></td></tr></table></figure></p><p>z 和 s 就构成了一个坐标矩阵 (-2,0),(-1,0),(0,0),(1,0),(-2,1),(-1,1),(0,1) … (2,0),(2,1)。实际上就是一个网格。</p><p>用matplotlib画等高线图，contourf可以填充等高线之间的空隙颜色，呈现出区域的分划状，所以很多分类机器学习模型的可视化常会借助其展现。<br>核心函数是plt.contourf()，输入的参数是x,y对应的网格数据以及此网格对应的高度值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import pandas as pd</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"> </span><br><span class="line"># 计算x,y坐标对应的高度值</span><br><span class="line">def f(x, y):</span><br><span class="line"> return (1-x/2+x**5+y**3) * np.exp(-x**2-y**2)</span><br><span class="line"> </span><br><span class="line"># 生成x,y的数据</span><br><span class="line">n = 256</span><br><span class="line">x = np.linspace(-3, 3, n)</span><br><span class="line">y = np.linspace(-3, 3, n)</span><br><span class="line"> </span><br><span class="line"># 把x,y数据生成mesh网格状的数据，因为等高线的显示是在网格的基础上添加上高度值</span><br><span class="line">X, Y = np.meshgrid(x, y)</span><br><span class="line"> </span><br><span class="line"># 填充等高线</span><br><span class="line">plt.contourf(X, Y, f(X, Y))</span><br><span class="line"># 显示图表</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p><p>plt.contourf(xx, yy, Z, cmap=plt.cm.Spectral)<br>cmap = plt.cm.Spectral实现的功能是给label为1的点一种颜色，给label为0的点另一种颜色。</p><p>tips:<br>计算正确率的向量方法，np.dot()进行矩阵乘法，如果相同，则乘积和为1，反之为0。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float((np.dot(Y,LR_predictions) + np.dot(1-Y,1-LR_predictions))/float(Y.size)*100)</span><br></pre></td></tr></table></figure></p><p>有时为保证能重现结果，设置相同的seed，每次生成的随机数相同。</p><pre><code>np.random.seed(2) # we set up a seed so that your output matches ours although the initialization is random.</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;np.meshgrid()&lt;br&gt;从坐标向量返回坐标矩阵，生成网格数据。&lt;br&gt;例如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/s
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2 Logistic Regression with a Neural Network mindset</title>
    <link href="http://yoursite.com/2018/09/04/2-Logistic-Regression-with-a-Neural-Network-mindset/"/>
    <id>http://yoursite.com/2018/09/04/2-Logistic-Regression-with-a-Neural-Network-mindset/</id>
    <published>2018-09-04T13:00:54.000Z</published>
    <updated>2018-09-05T04:24:13.360Z</updated>
    
    <content type="html"><![CDATA[<h4 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h4><ol><li><p>首先实现函数initialize_with_zeros(dim)对参数w和b进行初始化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">w = np.zeros((dim, 1))</span><br><span class="line">b = 0</span><br></pre></td></tr></table></figure></li><li><p>实现前向和后向传播算法 propagate(w, b, X, Y)，在此函数里计算损失cost，并求出w和b的梯度dw和db。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A = sigmoid( np.dot(w.T, X) + b )           # compute activation</span><br><span class="line">cost = -  np.sum( Y * np.log(A) + (1-Y) * np.log(1-A))  / m   # compute cost</span><br><span class="line"></span><br><span class="line">dw = np.dot(X,(A-Y).T) / m</span><br><span class="line">db = np.sum(A-Y) / m</span><br></pre></td></tr></table></figure></li><li><p>实现优化函数optimize(w, b, X, Y, num_iterations, learning_rate, print_cost = False)进行梯度下降。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">costs = []</span><br><span class="line">for i in range(num_iterations):</span><br><span class="line">   # Cost and gradient calculation (≈ 1-4 lines of code)</span><br><span class="line">   grads, cost = propagate(w, b, X, Y)</span><br><span class="line"></span><br><span class="line">   # Retrieve derivatives from grads</span><br><span class="line">   dw = grads[&quot;dw&quot;]</span><br><span class="line">   db = grads[&quot;db&quot;]</span><br><span class="line">       </span><br><span class="line">   # update rule </span><br><span class="line">   w = w - learning_rate*dw</span><br><span class="line">   b = b - learning_rate*db</span><br><span class="line">   if i % 100 == 0:</span><br><span class="line">       costs.append(cost)</span><br></pre></td></tr></table></figure></li></ol><p>最后返回的是 params, grads 和 costs。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">params = &#123;&quot;w&quot;: w,</span><br><span class="line">            &quot;b&quot;: b&#125;</span><br><span class="line">    </span><br><span class="line">grads = &#123;&quot;dw&quot;: dw,</span><br><span class="line">            &quot;db&quot;: db&#125;</span><br></pre></td></tr></table></figure></p><ol start="4"><li><p>实现预测函数 predict(w, b, X)，返回预测结果 Y_prediction。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A = sigmoid( np.dot(w.T, X) + b )</span><br><span class="line">for i in range(A.shape[1]):</span><br><span class="line">    if A[0][i] &lt;= 0.5:</span><br><span class="line">        Y_prediction[0][i] = 0</span><br><span class="line">    else:</span><br><span class="line">        Y_prediction[0][i] = 1</span><br></pre></td></tr></table></figure></li><li><p>将上述几步结合，实现最后的模型 model(X_train, Y_train, X_test, Y_test, num_iterations = 2000, learning_rate = 0.5, print_cost = False)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">w, b = initialize_with_zeros(X_train.shape[0])</span><br><span class="line">params, grads, costs = optimize(w, b, X_train, Y_train, num_iterations, learning_rate, print_cost = False)</span><br><span class="line">w = params[&apos;w&apos;]</span><br><span class="line">b = params[&apos;b&apos;]</span><br><span class="line">Y_prediction_test = predict(w, b, X_test)</span><br><span class="line">Y_prediction_train = predict(w, b, X_train)</span><br><span class="line">print(&quot;train accuracy: &#123;&#125; %&quot;.format(100 - np.mean(np.abs(Y_prediction_train - Y_train)) * 100))</span><br><span class="line">    print(&quot;test accuracy: &#123;&#125; %&quot;.format(100 - np.mean(np.abs(Y_prediction_test - Y_test)) * 100))</span><br></pre></td></tr></table></figure></li></ol><h4 id="numpy部分函数"><a href="#numpy部分函数" class="headerlink" title="numpy部分函数"></a>numpy部分函数</h4><p>np.squeeze() 从数组的形状中删除单维条目，即把shape中为1的维度去掉<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">x = np.array([[[0], [1], [2]]])</span><br><span class="line">print(x.shape)  # (1, 3, 1)</span><br><span class="line"></span><br><span class="line">x1 = np.squeeze(x)  # 从数组的形状中删除单维条目，即把shape中为1的维度去掉</span><br><span class="line">print(x1)  # [0 1 2]</span><br><span class="line">print(x1.shape)  # (3,)</span><br></pre></td></tr></table></figure></p><p>将矩阵 X : (a,b,c,d) 变换为矩阵 X_flatten ： (b ∗ c ∗ d, a) 时，使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X_flatten = X.reshape(X.shape[0], -1).T      # X.T is the transpose of X，参数为-1时，reshape函数会根据另一个参数的维度计算出数组的另外一个shape属性值。</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;算法步骤&quot;&gt;&lt;a href=&quot;#算法步骤&quot; class=&quot;headerlink&quot; title=&quot;算法步骤&quot;&gt;&lt;/a&gt;算法步骤&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;首先实现函数initialize_with_zeros(dim)对参数w和b进行初始化&lt;/p&gt;
&lt;figu
      
    
    </summary>
    
      <category term="深度学习习题" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B9%A0%E9%A2%98/"/>
    
    
      <category term="DeepLearning" scheme="http://yoursite.com/tags/DeepLearning/"/>
    
      <category term="习题" scheme="http://yoursite.com/tags/%E4%B9%A0%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>1 Python Basics with Numpy</title>
    <link href="http://yoursite.com/2018/09/04/1%20Python%20Basics%20with%20Numpy/"/>
    <id>http://yoursite.com/2018/09/04/1 Python Basics with Numpy/</id>
    <published>2018-09-04T02:45:01.000Z</published>
    <updated>2018-09-13T09:40:02.334Z</updated>
    
    <content type="html"><![CDATA[<hr><p>在iPython Notebooks中按下”SHIFT”+”ENTER”来运行相应的代码块。</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"># example of np.exp</span><br><span class="line">x = np.array([1, 2, 3])</span><br><span class="line">print(np.exp(x)) # result is (exp(1), exp(2), exp(3))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># example of vector operation</span><br><span class="line">x = np.array([1, 2, 3])</span><br><span class="line">print (x + 3)</span><br><span class="line">print (1.0 / x)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x_sum = np.sum(x_exp, axis = 1, keepdims = True)</span><br></pre></td></tr></table></figure><hr><p>np.shape 和 np.reshape().</p><p>X.shape 用来获得矩阵或者向量X的形状（维度）.<br>X.reshape(…) 改变X的维度.<br>例如， 将三维的图片向量  (length,height,depth=3) 更改为一维  (length∗height∗3,1)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v = image.reshape(image.shape[0]*image.shape[1]*image.shape[2],1)</span><br></pre></td></tr></table></figure></p><hr><p>求范数<br>x_norm=np.linalg.norm(x, ord=None, axis=None, keepdims=False)</p><ul><li>ord：范数类型<br>默认为第二范数，即算数平方根</li><li>axis：处理类型<br>axis=1表示按行向量处理，求多个行向量的范数<br>axis=0表示按列向量处理，求多个列向量的范数<br>axis=None表示矩阵范数。</li><li>keepdims：是否保持矩阵的二维特性</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 正则化</span><br><span class="line"># Compute x_norm as the norm 2 of x. Use np.linalg.norm(..., ord = 2, axis = ..., keepdims = True)</span><br><span class="line">x_norm = np.linalg.norm(x,axis=1,keepdims=True)</span><br><span class="line"># Divide x by its norm.</span><br><span class="line">x = x / x_norm</span><br></pre></td></tr></table></figure><hr><p>向量化<br>np.dot()：进行矩阵与矩阵，矩阵与向量之间的乘法。对于秩为1的数组x（即一维数组），执行对应位置相乘，然后再相加，np.dot(x)效果等同于np.sum(np.multiply(x))；对于秩不为1的二维数组，执行矩阵乘法运算。<br>np.multiply() 和 <em> 进行的是元素相乘。<br>乘号</em>：对数组执行对应位置相乘，对矩阵执行矩阵乘法运算。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">x1 = [9, 2, 5, 0, 0, 7, 5, 0, 0, 0, 9, 2, 5, 0, 0]</span><br><span class="line">x2 = [9, 2, 2, 9, 0, 9, 2, 5, 0, 0, 9, 2, 5, 0, 0]</span><br><span class="line"></span><br><span class="line">### VECTORIZED DOT PRODUCT OF VECTORS ###</span><br><span class="line">dot = np.dot(x1,x2)</span><br><span class="line"></span><br><span class="line">### VECTORIZED OUTER PRODUCT ###</span><br><span class="line">outer = np.outer(x1,x2)</span><br><span class="line"></span><br><span class="line">### VECTORIZED ELEMENTWISE MULTIPLICATION ###</span><br><span class="line">mul = np.multiply(x1,x2)</span><br><span class="line"></span><br><span class="line">np.multiply(A,B)       #数组对应元素位置相乘，输出为array</span><br><span class="line">(np.mat(A))*(np.mat(B))  #执行矩阵运算，输出为matrix</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;在iPython Notebooks中按下”SHIFT”+”ENTER”来运行相应的代码块。&lt;/p&gt;
&lt;hr&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cla
      
    
    </summary>
    
      <category term="深度学习习题" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B9%A0%E9%A2%98/"/>
    
    
      <category term="DeepLearning" scheme="http://yoursite.com/tags/DeepLearning/"/>
    
      <category term="习题" scheme="http://yoursite.com/tags/%E4%B9%A0%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>社会契约论</title>
    <link href="http://yoursite.com/2018/08/31/%E7%A4%BE%E4%BC%9A%E5%A5%91%E7%BA%A6%E8%AE%BA/"/>
    <id>http://yoursite.com/2018/08/31/社会契约论/</id>
    <published>2018-08-31T03:39:20.000Z</published>
    <updated>2018-09-07T10:04:44.564Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第一卷"><a href="#第一卷" class="headerlink" title="第一卷"></a>第一卷</h3><p>社会的人在社会中得到权利的同时也必定意味着要失去一些东西，不能够贪婪的无限制的顺从自己的任何欲望，我们所拥有的自由是被公意所约束着的社会的自由。</p><blockquote><p>人类由于社会契约而丧失的，乃是他的天然的自由以及对于他所企图的和所能得到的一切东西的那种无限的权利；而他所获得的，乃是社会的自由以及对于他所享有的一切东西的所有权。<br>只有嗜欲的冲动便是奴隶状态，而唯有服从人们自己为自己所规定的法律，才是自由。<br>《论社会形态》</p></blockquote><p>最后一句感觉说得很有道理。</p><blockquote><p>基本公约并没有摧毁自然的平等，反而是以道德的与法律的平等来代替自然所造成的人与人之间的身体上的不平等；从而，人们尽可以在力量上和才智上不平等，但是由于约定并且根据权利，他们却是人人平等的。<br>在坏政府的下面，这种平等只是虚有其表；它只能保持穷人处于贫困，保持富人处于占有。事实上，法律总是利于享有财富的人，而有害于一无所有的人；由此可见，唯有当人人都有一些东西而又没有人能有过多的东西的时候，社会状态才会对人类有益。<br>《论财产权》</p></blockquote><h3 id="第二卷"><a href="#第二卷" class="headerlink" title="第二卷"></a>第二卷</h3><p>多数也不一定是正确的，真理也不一定掌握在所谓的多数人手中，只是因为可能所谓的多还不够多，对于全体人民来说，只是一个小集团。而我觉得，当集团无限大，以致包括了全体人民，而集团的意志也就成了公意。</p><blockquote><p>人们总是愿意自己幸福，但人们并不总是能看清楚幸福。人民是绝不会被腐蚀的，但人民却往往会受欺骗，而且唯有在这时候，人民才好像会愿意要不好的东西。<br>众意与公意之间经常总是有很大的差别；公意只着眼于公共的利益，而众意只是个别意志的总和。但是，除掉这些个别意志正负相抵消的部分，剩下的总和仍是公意。<br>如果当人民能够充分了解情况并进行讨论时，公民彼此之间又没有任何勾结，那么从大量的小分歧中总可以产生公意，而且讨论的结果总会是好的。但是当形成了派别的时候，形成了以牺牲大集体为代价的小集团的时候，每一个这种集团的意志对它的成员来说就成为公意，而对国家来说则成为个别意志；这时候我们可以说，投票者的数目已经不再和人数相等，而只与集团的数目相等了。分歧在数量上是减少了，而所得的记过却更缺乏公意。最后，当这些集团中有一个是如此之大，以至于超过了其他一切集团的时候，那么结果你就不再有许多小的分歧的总和，而只有一个唯一的分歧；这时，就不再有公意，而占优势的意见便只不过是一种个别的意见。<br>《公意是否可能错误》</p></blockquote><p>人人都要为代表公意的祖国而战斗，具有公意是不可缺少的前提条件，否则就是变质的且没有任何意义的。</p><blockquote><p>由于契约的结果，他们的处境确实比起他们以前的情况更加可取得多；他们所做的并不是一项割让而是一项有利的交易，也就是以一种更美好的、更稳定的生活方式代替了不可靠的、不安定的生活方式，以自由代替了天然的独立，以自身的安全代替了自己侵害别人的权力，以一种由社会的结合保障其不可战胜的权利，代替了自己有可能被别人所制服的强力。他们所献给国家的个人生命也不断地在受着国家的保护；并且当他们冒生命之险去捍卫国家的时候，这时他们所做的事不也就是把自己得之于国家的东西重新给予国家吗？他们现在所做的事，难道不就是他们在自然状态里，当生活于不可避免的搏斗之中必须冒着生命的危险以保卫自己的生存所需时，他们格外频繁地、格外危险地所必须要做的事情吗？诚然，在必要时，人人都要为祖国而战斗；然而这样也就再没有一个人为自己而战斗了。为了保障我们的安全，只需冒一旦丧失这种安全时我们自身所必须去冒的种种危险中的一部分，这难道还不是收益吗？<br>《论主权权力的界限》</p></blockquote><p>这就是为什么需要法律，为什么要维护公平正义。没有公平正义的存在，“好人有好报，坏人有坏报”也是不可能存在的，反而可能会恰好相反。</p><blockquote><p>然而从人世来考察事物，则缺少了自然的制裁，正义的法则在人间便是虚幻的；当正直的人对一切人都遵守正义的法则，却没有人对他也遵守时，正义的法则就只不过造成了坏人的幸福和正直的人的不幸罢了。因此，就需要有约定和法律来把权利和义务结合在一起，并使正义能符合于它的目的。<br>《论法律》</p></blockquote><p>这里透露出了卢梭权力分立制约的思想。</p><blockquote><p>因为号令人的人如果不应该号令法律的话，那么号令法律的人也就更不应该号令人；否则法律受到他的感情所支配，便只能经常地贯彻他自己的不公正，而他个人的意见之有害于他自己的事业的神圣性，也就只能是永远不可避免。<br>《论立法者》</p></blockquote><p>在《论立法者》中，卢梭认为立法是一项超乎人力之上的事业，执行却又是一种形同无物的权威，人们无法理解为什么要接受良好的法律，从而产生了宗教，借助于申明的权威来要求人们服从国家法，他认为，在各个国家初创时，宗教是用来作为政治的工具的。</p><blockquote><p>太概况的概念与太遥远的目标，都同样地是超乎人们的能力之外的；每一个个人所喜欢的政府计划，不外是与他自己的个别利益有关的计划，他们很难认识到自己可以从良好的法律要求他们所作的不断牺牲之中得到怎样的好处。为了使一个新生的民族能够爱好健全的政治准则并遵循国家利益的根本规律，便必须倒果为因，使本来应该是制度的产物的社会精神转而凌驾于制度本身之上，并且使人们在法律出现之前，便可以成为应该是由于法律才能形成的那种样子。这样，立法者便既不能使用强力，也不能使用说理；因此就有必要求之于另外一种不以暴力而能约束人，不以论证而能说服人的权威了（指宗教）。<br>这种超乎人们的能力之外的崇高的道理，也就是立法者所以要把自己的决定托之于神道设教的道理，为的是好让神圣的权威来约束那些为人类的深思熟虑所无法感动的人们。但是并不是人人都可以代神明立言，也不是当他自称是神明的代言人时，他便能为人们所相信。唯有立法者的伟大的灵魂，才是足以证明自己使命的真正奇迹。人人都可以刻石立碑，或者购买神谕，或者假托通灵，或者训练一只小鸟向人耳边口吐神言，或者寻求其他的卑鄙手段来欺骗人民。只会搞这一套的人，甚至于也偶尔能纠集一群愚民；但是他却绝不会建立起一个帝国，而他那种荒唐的把戏很快地也就会随他本人一起破灭的。虚假的威望只能形成一种过眼云烟的联系，唯有智慧才能使之经久不衰。</p></blockquote><p>应该成为一切立法体系最终的目的全体最大的幸福是自由和平等。</p><blockquote><p>至于平等，这个名词绝不是指权力和财富的程度应当绝对相等；而是说，就权力而言，则它应该不能成为任何暴力，并且只有凭职位与法律才能加以行使；就财富而言，则没有一个公民可以富足得足以购买另一人，也没有一个公民穷得不得不出卖自身。这就要求大人物这一方必须节制财富和权势，而小人物这一方必须节制贪得和婪求。<br>有人说，这种平等是实践中所绝不可能存在的一种思辩虚构。但是，如果滥用权力是不可避免的，是不是因此就应该一点也不去纠正它了呢？恰恰因为事物的力量总是倾向于摧毁平等的，所以立法的力量就应该总是倾向于维持平等。<br>《论各种不同的立法体系》</p></blockquote><h3 id="第三卷"><a href="#第三卷" class="headerlink" title="第三卷"></a>第三卷</h3><blockquote><p>什么是政府呢？政府就是在臣民与主权者之间所建立的一个中间体，以便两者得以互相适合，它负责执行法律并维护社会的以及政治的自由。<br>主权者/政府=政府/国家，即：政府<em>政府=主权者</em>国家，这里将主权者看做一个整体，随着国家的增大（例如，人口数目的增多），就要求政府的力量也要相应地加强。<br>主权者将权力委托给政府，政府只能是由于主权者而存在的。如果行政官居然具有了一种比主权者的意志更为活跃的个别意志，并且他竟然使自己所掌握的公共力量服从于这个个别意志，以至于可以说有了两个主权者，一个是权利上的，而另一个则是事实上的；这时，社会的结合便会立即消灭，而政治题也便会立即解体。<br>困难就在于以什么方式在整体中安排这个附属的整体，从而使它在确定自己的体制时，决不至于变更总的体制，从而使它始终能够区别以保存自身为目的的个别力量和以保存国家为目的的公共力量；从而，一言以蔽之，使它永远准备着为人民而牺牲政府，却不是为政府而牺牲人民。<br>《政府总论》</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;第一卷&quot;&gt;&lt;a href=&quot;#第一卷&quot; class=&quot;headerlink&quot; title=&quot;第一卷&quot;&gt;&lt;/a&gt;第一卷&lt;/h3&gt;&lt;p&gt;社会的人在社会中得到权利的同时也必定意味着要失去一些东西，不能够贪婪的无限制的顺从自己的任何欲望，我们所拥有的自由是被公意所约束着的
      
    
    </summary>
    
      <category term="文学" scheme="http://yoursite.com/categories/%E6%96%87%E5%AD%A6/"/>
    
    
      <category term="摘抄" scheme="http://yoursite.com/tags/%E6%91%98%E6%8A%84/"/>
    
      <category term="文学" scheme="http://yoursite.com/tags/%E6%96%87%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>论人类不平等的起源</title>
    <link href="http://yoursite.com/2018/08/28/%E8%AE%BA%E4%BA%BA%E7%B1%BB%E4%B8%8D%E5%B9%B3%E7%AD%89%E7%9A%84%E8%B5%B7%E6%BA%90/"/>
    <id>http://yoursite.com/2018/08/28/论人类不平等的起源/</id>
    <published>2018-08-28T05:05:28.000Z</published>
    <updated>2018-08-28T14:29:50.835Z</updated>
    
    <content type="html"><![CDATA[<p>《论人类不平等的起源》是卢梭的早期作品之一，英文原书名为“A Discourse On Inequality”。在此书中，卢梭揭示出私有制是人类不平等的起源和基础，他认为自然状态的野蛮人是独居的，彼此间没有任何联系，对同类既无所需要，也无加害意图，甚至从来不能辨认他同类中的任何人，因此，他们是平等的。但随着人类独具的自我能力被发挥，人类发明了冶金和农业，土地的耕种最终导致了土地的分配，即私有制的确立。私有制一旦被承认，由于人们才能的差异，逐渐产生了贫困和奴役。富人们为了保护他们的财富，便想借助于那些攻击他们的力量来保护自己，于是他们通过诱骗说服邻人出让权利，从而永久确立了保障私有财产和承认不平等的契约，即法律，建立起了国家政治体制，于是产生了人与人之间在政治上的不平等，完成了人类从自然上的不平等到政治上不平等的过度。<br>在阅读此书的过程中，对书中有些篇章段落比较有感触，遂摘抄如下。</p><h4 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h4><p>在社会中，我们正因为要与其他人不可避免的产生联系，才有了种种的束缚，这也许是一个社会人和自然人的根本不同吧。</p><blockquote><p>奴役的锁链仅仅是在人们相互依赖和彼此需要的时候才能够形成；彼此的需要使人们彼此结合起来。如果不首先使一个人陷入如果离开某一人就不能生存的状态，那么这个人就永远不可能奴役这个人。这种情形在自然状态下是不存在的。在自然状态中，每个人都不受束缚，即使最强大的人动用其力量也是徒然。</p></blockquote><p>人啊，往往不能节制自己的欲望。。。</p><blockquote><p>野兽根据本能决定取舍，而人类则通过自由意志进行取舍。这意味着野兽即使面对诱惑也不会去违背自然法则；但是人类却往往尽管面对损害，也会去违背这些规则。正是因为这样，生活放荡的人们沉溺于种种可能招致疾病与死亡的过度享乐中不能自拔，这是因为意志破坏了器官：当自然的需要已经得到满足的时候，意志还在不断地提出要求。</p></blockquote><p>书中指出了怜悯心是人最原始的情感，也许这也从一个侧面说明了人性本善，人类在变得理性的同时，为自己谋求利益的同时也可能变成全面的利己，而失去了最本真的自我。</p><blockquote><p>上帝赋予了人类看到同类受苦天生就会产生的一种反感。这种反感，在特定的情况下缓和了他的强烈的自尊心，或者在自尊心产生之前缓和了他自我保存的愿望，从而使他为自己谋利的热情受到限制。它是最普遍的美德，并且因为它在人类拥有理性之前就已经展现，因此对于人类是最为有用的。怜悯心是如此自然的一种美德，甚至野兽有的时候也会显露一些怜悯迹象。无需花费笔墨去描述母兽对待她们的幼崽是多么的温柔，也无需描述她们为了保护自己的孩子可以面对多么严峻的危险，我们每天都可以观察到马匹会避免践踏任何有生命的东西。一个动物从同类的尸体旁走过，总是不能遏制内心的悲伤，甚至有些动物会为已经死去的同类做某种形式的葬礼。我们很欣赏地看到《蜜蜂的寓言》的作者也不得不承认人是拥有怜悯心和情感的动物，在他描述的例子中，他抛弃了冷峻、世故的文笔，呈现给我们一个令人心碎的场景：一个被监禁的人透过他的牢笼，亲眼目睹了一头野兽从一位母亲的怀抱中夺走了她的孩子，用它致命的牙齿咬碎了孩子虚弱的身体，用它的利爪撕开了孩子鲜活的内脏。这个目击者虽然与这件事情没有个人利益上的关联，但是当他看到这个场景的那一瞬，他一定感受到了惊心动魄！目睹了这一切，却不能做任何事情去帮助昏厥的母亲和垂死的孩子，他一定是感到非常痛苦！这就是纯粹的自然感动，它先于一切的思考；这就是自然的怜悯心的力量，即使最堕落的道德也不能够破坏它。因为，我们每天在剧院中都会看到人们为一些不幸的人的悲惨遭遇动容，甚至伤心落泪；但如果他们站在暴君的位置上，只会增加对他的敌人的虐待。<br>事实上，除了对弱者、罪犯、人类整体的同情外，还有什么可以称得上是慷慨、仁慈和博爱？所谓的爱心，甚至友谊，如果我们正确地理解，就会发现它们仅仅是对于特定事物的恒久的怜悯心的产物；因为希望一个人不遭受痛苦，不就是希望他幸福吗？即使怜悯心仅仅是将我们置身于受难者的位置而产生的一种情感，这种说法除了增强我的论点的说服力外，没有任何意义。事实上，旁观的动物越是与受难者引起共鸣，怜悯心就越是强烈。现在，很显然，自然状态中的共鸣比理性状态中的共鸣深切不知几万倍。理性使人们产生自尊心，而增强自尊心的则是思考。理性使得人们追求自保；思考使得人们远离所有打扰或者妨碍他的事情。哲学使得人与世隔绝，促使人们在看到他人受苦时暗自说：“如果你要死就去死吧，只要我是安全的。” 除了社会整体的危险，没有什么可以打扰哲学家的清梦，把他从床上拖起来。人们可以肆无忌惮地在他的窗下杀死同类，因为这位哲人只需将手捂在耳朵上并且为自己争辩几句，就能够阻挡他内心澎湃着的对于受害者的怜悯。野蛮人完全不具备这令人钦佩的能力，由于缺少智慧和理智，他们总是不加思考地服从于人类的情感。<br>怜悯是一种自然的情感，它缓和了个体出于自利的行为，从而促进了人类整体的相互保存。是怜悯心使得我们看到他人受难时，不假思索地伸出援手；是怜悯心以其特有的优势，在自然状态中替代了法律、道德、美德的位置。它的优势就是没有一个人能够违抗它温柔的声音。它使得强壮的野蛮人，只要有从别的地方获取食物的可能就不会从幼小的孩童和孱弱的老人手中掠夺他们来之不易的东西。它使得合乎自然天性的格言“在为自己谋求利益的时候，尽可能少伤害他人”代替了富有理性正义的格言“己所不欲勿施于人”，从而激励所有的人；尽管前者远不如后者完善，但可能会更有用。总之，在我们探寻为什么任何人作恶时都会感到内疚的过程中，我们与其在那些微妙的争论中寻找，不如在这种自然的情感中寻找，即使作恶者对教育的格言一无所知。</p></blockquote><h4 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h4><p>有时候，享受变成了习惯，得到成了理所当然，却失去了其最初的快乐。</p><blockquote><p>人们可以享受大量的闲暇时光，他们用这些时光获得了许多为其祖先所不知道的享受。这是他们无意中为自己戴上的第一个枷锁，也是为自己的后代准备了第一个罪恶之源。因为这种享受不仅持续地侵蚀我们的身体与头脑，使他们虚弱下去，而且享受一旦成为习惯，就失去了快乐的力量，同时蜕化成生活的真正需要。于是，得不到它们的残酷比得到它们的幸福更大。当人们占有它们的时候，并不感到幸福，失去的时候却十分苦恼。</p></blockquote><p>这段阐述了政治社会的起源，也提醒了我们一种思考的误区：不要想当然地根据自己看到的事物，去判断我们从来没有见过的事情，也许极不相同。正如书中所说的：<strong>因此我们一定不能将被奴役的人们的堕落状态作为判断人类的自然天性是倾向于受奴役还是反抗奴役的基础，而是应当根据一切致力于抵抗压迫的自由民族取得的巨大成就来判断。</strong></p><blockquote><p>关于政治社会的起源，有人认为起源于强者的征服或弱者的联合。<br>在第一种情形下，征服权本身并不是一种真正的权利，因此也就不能成为其他权利的基础。除非被征服的民族完全恢复了自由，人们自愿选择征服者作为他们的首领，否则胜利者和被征服者之间将永远陷入相互的战争。在征服者由被征服的民族自愿推选为首领之前，不论签订了什么样的投降条约，由于这些条约都是以暴力作为唯一基础的，以此其本身就是无效的，这意味着，在这种假定的基础上是不可能产生任何真正的社会和政治组织的，除了强者的法律外，不可能有其他任何的法律。<br>在第二种情形中，强弱的含义是模糊不清的。在财产权或者先占权的确立和政治政府建立的间隔期间，这两个字的意义倒不如穷和富更加贴切。因为在法律制度产生以前，一个人要想驱使他人，除了袭击他的财产或者将自己的财产分给他们一些之外，是没有任何办法的。<br>因为穷人除了自由外没有什么可以失去的了，所以要他们毫无所获地自愿交出现今仅存的珍藏将会是最荒谬的事情。对于富人却恰恰相反，他们非常容易受到攻击，他们财产的每一个部分都可能成为攻击的目标，因此要伤害他们是比较容易的事。所以，富人需要为自身的保护采取更多的防护措施。因此，我们可以合理地断言，制度是应当由受益人而非受害者创造的。<br>社会起初不过是由少数几个公约组成的，每个人都必修遵守它们，并由共同体对个体承担保证人的责任。只有当经验表明这样的组织是如何脆弱的时候，违法者是多么轻易就能逃脱刑事案件的认定和惩罚的时候（因为只有公众才能对违法者的罪行作证和裁判），只有法律被人们想尽千百种方法规避的时候，只有不便和混乱持续增加的时候，人们才终于想到冒险将公共权力委托给特定的个人，才想到把执行人民的决议的任务委托给官员。然而，认为人们一开始就会无条件、义无反顾地投入一个专制首领的怀抱，认为狂妄尊大、未被驯服的人们为了维护公共安全所想到的第一个办法就是投身于奴隶制是不大合理的。事实上，如果不是为了保护自己免受压迫，不是为了保护构成他们生存要素的财产、自由、生命，他们为什么要给自己找到一个统治者呢？人与人关系中最坏的情况不外乎发现自己受到另一个人的支配。如果人们只是为了保护他们仅有的东西才会需要首领的帮助，那么他们一开始就将需要保存的东西交到首领的手中，不是违背常识的吗？<br>对于人们作出的如此巨大的权利让予，首领能给予他们什么样的均等利益作为回报呢？如果他胆敢假借保护民众的借口要求人们让予权利，人们很快就会用寓言中的一句话作为给他的答复：“敌人对我们也不过如此吧？” 因此，人们为自己寻找首领的原因，是为了保护他们的自由，而非找人奴役他们，这是所有的政治权力的基础原则。普林尼曾对图拉真说：“我们如果需要一位国王，那是为了他能够保护我们不被任何人奴役。”<br>政治家们关于爱好自由所做的那些诡辩与哲学家们关于自然状态所做地那些诡辩如出一辙。他们根据自己看到的事物，判断他们从来没有见过的极不相同的事情。他们因为看到奴隶忍受奴役时的耐心而断定人们就具有受奴役的天然倾向，却忘记了自由如同天真和美德，只有当一个人拥有它的时候才能够感受到它的价值，一旦人们失去了它，就失去了对它的喜爱。文明人会毫无怨言地戴着他们的枷锁，野蛮人则永远不会向枷锁低头，正如一匹未被驯服的野马，一旦有缰绳有些许靠近，它就会竖起鬃毛，用蹄子在地上刨土，激烈地暴跳，但是一匹被驯服的马就会耐心地忍受鞭子和马刺。因而，野蛮人是宁愿在暴风雨中享受自由，也不愿在安宁中受奴役的。因此我们一定不能将被奴役的人们的堕落状态作为判断人类的自然天性是倾向于受奴役还是反抗奴役的基础，而是应当根据一切致力于抵抗压迫的自由民族取得的巨大成就来判断。我知道被奴役的人们只会不断吹嘘他们在枷锁中享受到的和平与安宁，其实他们是把悲惨的奴役状态成为和平。但是，当我看到自由民族为了保护他们仅有的财产时，他们甘愿牺牲快乐、安宁、财富、权力，甚至生命本身的时候；当我看到一些生来自由的动物，因为憎恨被囚禁而撞向牢笼的栅栏，撞破了头的时候；当我看到成千上万赤裸裸的野蛮人鄙视欧洲人的骄奢淫逸，只为保持他们的独立而甘冒饥饿、战火、刀剑和死亡风险的时候，我感到关于“自由”的讨论是与奴隶无关的。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;《论人类不平等的起源》是卢梭的早期作品之一，英文原书名为“A Discourse On Inequality”。在此书中，卢梭揭示出私有制是人类不平等的起源和基础，他认为自然状态的野蛮人是独居的，彼此间没有任何联系，对同类既无所需要，也无加害意图，甚至从来不能辨认他同类中的
      
    
    </summary>
    
      <category term="文学" scheme="http://yoursite.com/categories/%E6%96%87%E5%AD%A6/"/>
    
    
      <category term="摘抄" scheme="http://yoursite.com/tags/%E6%91%98%E6%8A%84/"/>
    
      <category term="文学" scheme="http://yoursite.com/tags/%E6%96%87%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>朴素贝叶斯法</title>
    <link href="http://yoursite.com/2018/08/11/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%B3%95/"/>
    <id>http://yoursite.com/2018/08/11/朴素贝叶斯法/</id>
    <published>2018-08-11T11:17:46.000Z</published>
    <updated>2018-08-28T14:33:41.229Z</updated>
    
    <content type="html"><![CDATA[<h3 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h3><h4 id="公式推导"><a href="#公式推导" class="headerlink" title="公式推导"></a>公式推导</h4><p>朴素贝叶斯法是基于贝叶斯定理和特征条件独立假设的分类方法，即对给定的输入 $x$，预测其类别 $y$。<br>此方法的思路是首先由训练数据计算 $P(Y)$ 和 $P(X|Y)$ 的估计,然后得到联合概率分布<br>$$ P(X,Y) = P(Y)P(X|Y) $$<br>之后利用贝叶斯定理及学到的联合概率分布计算 $X$ 属于类别 $Y$ 的概率<br>$$ P(Y|X) = \frac{P(X,Y)}{P(X)} = \frac{P(Y)P(X|Y)}{\mathop{\sum}_{Y}P(Y)P(X|Y)}$$<br>对于给定的输入 $x$，通过上式计算 $x$ 属于类别 $c_k$ 的概率 $ P(Y=c_k|X=x) $，即<br>$$ P(Y=c_k|X=x) =  \frac{P(Y=c_k)P(X=x|Y=c_k)}{\mathop{\sum}_{k}P(Y=c_k)P(X=x|Y=c_k)}$$<br>又由朴素贝叶斯法的特征条件独立性假设，有<br>$$\begin{equation}\begin{split}<br>P(X=x|Y=c_k) &amp;=P( X^{(1)}=x^{(1)},\cdots,X^{(n)}=x^{(n)} | Y=c_k )\\<br>&amp;= \prod_{j=1}^{n} P(X^{(j)}=x^{(j)}|Y=c_k)<br>\end{split}\end{equation}$$<br>其中，$x$ 为 $n$ 维向量，$x^{(j)}$ 为 $x$ 的第 $j$ 个特征。故<br>$$ P(Y=c_k|X=x) = \frac{P(Y=c_k)\prod_{j}P(X^{(j)}=x^{(j)}|Y=c_k)}{\mathop{\sum}_{k}P(Y=c_k)\prod_{j}P(X^{(j)}=x^{(j)}|Y=c_k)} , k=1,2,\dots,K$$<br>将 $x$ 分到后验概率最大的类中，朴素贝叶斯分类器可表示为<br>$$ y = f(x) = arg \max_{c_k} \frac{P(Y=c_k)\prod_{j}P(X^{(j)}=x^{(j)}|Y=c_k)}{\mathop{\sum}_{k}P(Y=c_k)\prod_{j}P(X^{(j)}=x^{(j)}|Y=c_k)}$$<br>又因为上式中分母对于所有 $c_k$ 都是相同的，故上式可以简化为<br>$$ y = arg \max_{c_k} P(Y=c_k)\prod_{j}P(X^{(j)}=x^{(j)}|Y=c_k) $$</p><p>由上式可知，只要由训练数据估计出每一个类别的概率 $P(Y=c_k)$ 和输入的每一个特征值在某一类别下的概率 $P(X^{(j)}=x^{(j)}|Y=c_k)$，便可进行预测。下面介绍进行估计的两种方法。</p><h4 id="参数估计"><a href="#参数估计" class="headerlink" title="参数估计"></a>参数估计</h4><h5 id="极大似然估计"><a href="#极大似然估计" class="headerlink" title="极大似然估计"></a>极大似然估计</h5><p>假设训练数据集为 $T = \{(x_1,y_1),\dots,(x_n,y_n)\}$。<br>先验概率 $P(Y=c_k)$ 的极大似然估计为<br>$$ P(Y=c_k) = \frac{\sum_{i=1}^{N}I(y_i=c_k)}{N} $$<br>设第 $j$ 个特征 $x^{(j)}$ 可能取值的集合为 $\{a_{j1},\dots,a_{jS_j}\}$，条件概率 $P(X^{(j)}=a_{jl}|Y=c_k)$ 的极大似然估计为<br>$$ P(X^{(j)}=a_{jl}|Y=c_k) = \frac{\sum_{i=1}^{N}I(x_{i}^{(j)}=a_{jl},y_i=c_k)}{\sum_{i=1}^{N}I(y_i=c_k)} $$<br>$$ j=1,2,\dots,n;l=1,2,\dots,S_j;k=1,2,\dots,K $$<br>其中，$x_{i}^{j}$ 是第 $i$ 个样本的第 $j$ 个特征；$a_{jl}$ 是第 $j$ 个特征可能取的第 $l$ 个值； $I$ 为指示函数，满足取 $1$，否则取 $0$。</p><h5 id="贝叶斯估计"><a href="#贝叶斯估计" class="headerlink" title="贝叶斯估计"></a>贝叶斯估计</h5><p>极大似然估计可能会出现所要估计的概率值为0的情况，在随机变量各个取值的频数上赋予一个正数 $\lambda \gt 0$，常取 $\lambda = 1$，称为拉普拉斯平滑。<br>$$ P_{\lambda}(Y=c_k) = \frac{\sum_{i=1}^{N}I(y_i=c_k)+{\lambda}}{N+K\lambda} $$<br>$$ P_{\lambda}(X^{(j)}=a_{jl}|Y=c_k) = \frac{\sum_{i=1}^{N}I(x_{i}^{(j)}=a_{jl},y_i=c_k)+\lambda}{\sum_{i=1}^{N}I(y_i=c_k)+S_j\lambda} $$</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>训练一个朴素贝叶斯分类器并确定 $x=(2,S)^T$ 的类标记 $y$。表中 $X^{(1)}$，$X^{(2)}$ 为特征，取值集合分别为 $A_1 = \{1,2,3\}$， $A_2 = \{S,M,L\}$， $Y$ 为类标记，$Y \in C =\{1,-1\}$。</p><p>训练数据 train_data.csv<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ID,X1,X2,Y</span><br><span class="line">1,1,S,-1</span><br><span class="line">2,1,M,-1</span><br><span class="line">3,1,M,1</span><br><span class="line">4,1,S,1</span><br><span class="line">5,1,S,-1</span><br><span class="line">6,2,S,-1</span><br><span class="line">7,2,M,-1</span><br><span class="line">8,2,M,1</span><br><span class="line">9,2,L,1</span><br><span class="line">10,2,L,1</span><br><span class="line">11,3,L,1</span><br><span class="line">12,3,M,1</span><br><span class="line">13,3,M,1</span><br><span class="line">14,3,L,1</span><br><span class="line">15,3,L,-1</span><br></pre></td></tr></table></figure></p><p>代码实现 naivebayes.py<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"> # -*- coding: utf-8 -*-</span><br><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def add2dict(thedict, key_a, key_b, val):</span><br><span class="line">    if key_a in thedict.keys():</span><br><span class="line">        thedict[key_a].update(&#123;key_b: val&#125;)</span><br><span class="line">    else:</span><br><span class="line">        thedict.update(&#123;key_a:&#123;key_b: val&#125;&#125;)        </span><br><span class="line"></span><br><span class="line">def conditionalProbability(obj, attribute, clazz, lambd):</span><br><span class="line">    C = obj[clazz].value_counts()</span><br><span class="line">    label = C.index</span><br><span class="line">    counts = C.values</span><br><span class="line"></span><br><span class="line">    CP = dict()</span><br><span class="line">    for i in range(label.size):</span><br><span class="line">        for j in range(attribute.size):</span><br><span class="line">            temp = obj[obj[clazz] == label[i]][attribute[j]] </span><br><span class="line">            CC = temp.value_counts()</span><br><span class="line">            Sj = obj[attribute[j]].value_counts().index.size</span><br><span class="line">            P = ( CC + lambd) / ( counts[i] + Sj*lambd)</span><br><span class="line">            add2dict(CP,label[i],attribute[j],P) # Using dict to store probabilities</span><br><span class="line">    return CP</span><br><span class="line"></span><br><span class="line">def priorProbability(obj, clazz, lambd):</span><br><span class="line">    C = obj[clazz].value_counts()</span><br><span class="line">    N = float(obj.index.size)</span><br><span class="line">    K = float(C.index.size)</span><br><span class="line">    P = ( C + lambd ) / ( N + K*lambd)</span><br><span class="line">    return P</span><br><span class="line"></span><br><span class="line">def predicts(x, obj, attribute, clazz,lambd):</span><br><span class="line">    label = obj[clazz].value_counts().index # Types of class</span><br><span class="line">    P = priorProbability(obj,clazz, lambd) # Prior probability</span><br><span class="line">    CP = conditionalProbability(obj, attribute, clazz, lambd) # Conditional probability</span><br><span class="line">    max_p = 0 # Probability of the most likely class</span><br><span class="line">    max_c = &apos;&apos; # The most likely class</span><br><span class="line">    for i in range(label.size):</span><br><span class="line">        cur_max_p = 1</span><br><span class="line">        for j in range(attribute.size):</span><br><span class="line">            cur_max_p *= CP[label[i]][attribute[j]][x[j]]</span><br><span class="line">        cur_max_p *= P[label[i]]</span><br><span class="line">        if cur_max_p &gt; max_p:</span><br><span class="line">            max_c = str(label[i])</span><br><span class="line">            max_p = cur_max_p</span><br><span class="line">    return [max_c,max_p]</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(&apos;train_data.csv&apos;, encoding=&apos;utf-8&apos;)</span><br><span class="line">[max_c,max_p] = predicts([2,&apos;S&apos;],df, df.columns.drop(&apos;Y&apos;).drop(&apos;ID&apos;), &apos;Y&apos;, 1)</span><br><span class="line">print(max_c,max_p)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;理论&quot;&gt;&lt;a href=&quot;#理论&quot; class=&quot;headerlink&quot; title=&quot;理论&quot;&gt;&lt;/a&gt;理论&lt;/h3&gt;&lt;h4 id=&quot;公式推导&quot;&gt;&lt;a href=&quot;#公式推导&quot; class=&quot;headerlink&quot; title=&quot;公式推导&quot;&gt;&lt;/a&gt;公式推导&lt;/h
      
    
    </summary>
    
      <category term="统计机器学习" scheme="http://yoursite.com/categories/%E7%BB%9F%E8%AE%A1%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="朴素贝叶斯" scheme="http://yoursite.com/tags/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/"/>
    
      <category term="统计学习" scheme="http://yoursite.com/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>MathJax使用LaTeX语法编写数学公式教程</title>
    <link href="http://yoursite.com/2018/08/11/MathJax%E4%BD%BF%E7%94%A8LaTeX%E8%AF%AD%E6%B3%95%E7%BC%96%E5%86%99%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/08/11/MathJax使用LaTeX语法编写数学公式教程/</id>
    <published>2018-08-11T08:51:30.000Z</published>
    <updated>2018-08-11T11:16:41.702Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转载于<a href="https://www.zybuluo.com/knight/note/96093" target="_blank" rel="noopener">@knight</a>博客，感谢博主的分享。</p></blockquote><h3 id="如何插入公式"><a href="#如何插入公式" class="headerlink" title="如何插入公式"></a>如何插入公式</h3><p>LaTeX的数学公式有两种：行中公式和独立公式。行中公式放在文中与其它文字混编，独立公式单独成行。</p><p>行中公式可以用如下方法表示：</p><p>\$数学公式\$</p><p>独立公式可以用如下方法表示：</p><p>\$\$ 数学公式 \$\$</p><p>例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$J_\alpha(x) = \sum_&#123;m=0&#125;^\infty \frac&#123;(-1)^m&#125;&#123;m! \Gamma (m + \alpha + 1)&#125; &#123;\left(&#123; \frac&#123;x&#125;&#123;2&#125; &#125;\right)&#125;^&#123;2m + \alpha&#125;$</span><br></pre></td></tr></table></figure></p><p>显示：</p><p>$J_\alpha(x) = \sum_{m=0}^\infty \frac{(-1)^m}{m! \Gamma (m + \alpha + 1)} {\left({ \frac{x}{2} }\right)}^{2m + \alpha}$</p><h3 id="如何插入公式大括号"><a href="#如何插入公式大括号" class="headerlink" title="如何插入公式大括号"></a>如何插入公式大括号</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$$f(x)=</span><br><span class="line">\begin&#123;cases&#125;</span><br><span class="line">0&amp; \text&#123;x=0&#125;\\\\</span><br><span class="line">1&amp; \text&#123;x!=0&#125;</span><br><span class="line">\end&#123;cases&#125;$$</span><br></pre></td></tr></table></figure><p>$$f(x)=<br>\begin{cases}<br>0&amp; \text{x=0}\\<br>1&amp; \text{x!=0}<br>\end{cases}$$</p><h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$$\begin&#123;bmatrix&#125; </span><br><span class="line">1&amp;x&amp;x^2\\\\ </span><br><span class="line">1&amp;y&amp;y^2\\\\ </span><br><span class="line">1&amp;z&amp;z^2 </span><br><span class="line">\end&#123;bmatrix&#125;$$</span><br></pre></td></tr></table></figure><p>$$\begin{bmatrix}<br>1&amp;x&amp;x^2\\<br>1&amp;y&amp;y^2\\<br>1&amp;z&amp;z^2<br>\end{bmatrix}$$ </p><h3 id="如何输入上下标"><a href="#如何输入上下标" class="headerlink" title="如何输入上下标"></a>如何输入上下标</h3><p>^表示上标， _表示下标。如果上下标的内容多于一个字符，要用{}把这些内容括起来当成一个整体。上下标是可以嵌套的，也可以同时使用。</p><p>例子：<code>$x^{y^z}=(1+{\rm e}^x)^{-2xy^w}$</code></p><p>显示：$x^{y^z}=(1+{\rm e}^x)^{-2xy^w}$</p><p>另外，如果要在左右两边都有上下标，可以用<code>\sideset</code>命令。</p><p>例子：<code>$\sideset{^1_2}{^3_4}\bigotimes$</code></p><p>显示：$ \sideset{^1_2}{^3_4} \bigotimes $</p><p><code>$$\max_{k}$$</code><br>$$\max_{k}$$<br><code>$$\mathop{argmax}_{K}$$</code><br>$$\mathop{argmax}_{K}$$</p><h3 id="如何输入括号和分隔符"><a href="#如何输入括号和分隔符" class="headerlink" title="如何输入括号和分隔符"></a>如何输入括号和分隔符</h3><p>()、[]和|表示自己，{}表示{}。当要显示大号的括号或分隔符时，要用\left和\right命令。</p><p>例子：<code>$f(x,y,z) = 3y^2z \left( 3+\frac{7x+5}{1+y^2} \right)$</code></p><p>显示：$f(x,y,z) = 3y^2z \left( 3+\frac{7x+5}{1+y^2} \right)$</p><p>有时候要用<code>\left.</code>或<code>\right.</code>进行匹配而不显示本身。</p><p>例子：<code>$\left. \frac{du}{dx} \right| _{x=0}$</code></p><p>显示：$\left. \frac{du}{dx} \right| _{x=0}$</p><h3 id="如何输入分数"><a href="#如何输入分数" class="headerlink" title="如何输入分数"></a>如何输入分数</h3><p>例子：<code>$\frac{1}{3}$</code>　或　<code>$1 \over 3$</code></p><p>显示：$\frac{1}{3}$　或　$1 \over 3$</p><h3 id="如何输入开方"><a href="#如何输入开方" class="headerlink" title="如何输入开方"></a>如何输入开方</h3><p>例子：<code>$\sqrt{2}$</code>　和　<code>$\sqrt[n]{3}$</code></p><p>显示：$\sqrt{2}$　和　$\sqrt[n]{3}$</p><h3 id="如何输入省略号"><a href="#如何输入省略号" class="headerlink" title="如何输入省略号"></a>如何输入省略号</h3><p>数学公式中常见的省略号有两种，\ldots表示与文本底线对齐的省略号，\cdots表示与文本中线对齐的省略号。</p><p>例子：<code>$f(x_1,x_2,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2$</code></p><p>显示：$f(x_1,x_2,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2$</p><h3 id="如何输入矢量"><a href="#如何输入矢量" class="headerlink" title="如何输入矢量"></a>如何输入矢量</h3><p>例子：<code>$\vec{a} \cdot \vec{b}=0$</code></p><p>显示：$\vec{a} \cdot \vec{b}=0$</p><h3 id="如何输入积分"><a href="#如何输入积分" class="headerlink" title="如何输入积分"></a>如何输入积分</h3><p>例子：<code>$\int_0^1 x^2 {\rm d}x$</code></p><p>显示：$\int_0^1 x^2 {\rm d}x$</p><h3 id="如何输入极限运算"><a href="#如何输入极限运算" class="headerlink" title="如何输入极限运算"></a>如何输入极限运算</h3><p>例子：<br><code>$\lim\limits_{n \rightarrow +\infty} \frac{1}{n(n+1)}$</code></p><p><code>$$\lim_{n \rightarrow +\infty} \frac{1}{n(n+1)}$$</code></p><p>显示：$\lim\limits_{n \rightarrow +\infty} \frac{1}{n(n+1)}$<br>$$\lim_{n \rightarrow +\infty} \frac{1}{n(n+1)}$$ </p><blockquote><p>注:在latex中输入极限，主要的一种形式是使用<code>\lim</code>，输出的就是极限的原样。<br>如果在<code>$*****$</code>环境中，使用上下标起不到作用，在<code>$$******$$</code>中使用下标，会使下标部分出现在limit之下。<br>在文章中间，使用这种形式的极限，可以选择使用这种形式<code>\lim\limits_{t \to \infty }{x(t)}</code>。<br>上下极限的输入textfriend里面直接就有。<br>另外一点需要注意的是，极限的下标如果有多行的话，使用断行，有几种方法：可以使用<code>array</code>或者<code>substack</code>命令，也可以使用<code>\stackrel{top}{bot}</code>或者<code>mathop</code>命令。</p></blockquote><h3 id="如何输入累加、累乘运算"><a href="#如何输入累加、累乘运算" class="headerlink" title="如何输入累加、累乘运算"></a>如何输入累加、累乘运算</h3><p>例子：<code>$\sum_{i=0}^n \frac{1}{i^2}$　和　$\prod_{i=0}^n \frac{1}{i^2}$</code></p><p>显示：$\sum_{i=0}^n \frac{1}{i^2}$　和　$\prod_{i=0}^n \frac{1}{i^2}$</p><h3 id="如何进行公式应用"><a href="#如何进行公式应用" class="headerlink" title="如何进行公式应用"></a>如何进行公式应用</h3><p>例子：<code>$ r = r_F + \beta(r_M-r_F) - \epsilon $</code></p><p>显示： $ r = r_F + \beta(r_M-r_F) - \epsilon $</p><h3 id="如何输入希腊字母"><a href="#如何输入希腊字母" class="headerlink" title="如何输入希腊字母"></a>如何输入希腊字母</h3><p>例子：</p><p>\alpha　A　\beta　B　\gamma　\Gamma　\delta　\Delta　\epsilon　E<br>\varepsilon　　\zeta　Z　\eta　H　\theta　\Theta　\vartheta<br>\iota　I　\kappa　K　\lambda　\Lambda　\mu　M　\nu　N<br>\xi　\Xi　o　O　\pi　\Pi　\varpi　　\rho　P<br>\varrho　　\sigma　\Sigma　\varsigma　　\tau　T　\upsilon　\Upsilon<br>\phi　\Phi　\varphi　　\chi　X　\psi　\Psi　\omega　\Omega</p><p>显示： </p><p>$\alpha$　$A$　$\beta$　$B$　$\gamma$　$\Gamma$　$\delta$　$\Delta$　$\epsilon$　$E$<br>$\varepsilon$　　$\zeta$　$Z$　$\eta$　$H$　$\theta$　$\Theta$　$\vartheta$<br>$\iota$　$I$　$\kappa$　$K$　$\lambda$　$\Lambda$　$\mu$　$M$　$\nu$　$N$<br>$\xi$　$\Xi$　$o$　$O$　$\pi$　$\Pi$　$\varpi$　　$\rho$　$P$<br>$\varrho$　　$\sigma$　$\Sigma$　$\varsigma$　　$\tau$　$T$　$\upsilon$　$\Upsilon$<br>$\phi$　$\Phi$　$\varphi$　$\chi$　$X$　$\psi$　$\Psi$　$\omega$　$\Omega$</p><h3 id="如何输入其它特殊字符"><a href="#如何输入其它特殊字符" class="headerlink" title="如何输入其它特殊字符"></a>如何输入其它特殊字符</h3><h4 id="关系运算符："><a href="#关系运算符：" class="headerlink" title="关系运算符："></a>关系运算符：</h4><p>±：\pm<br>×：\times<br>÷：\div<br>∣：\mid<br>∤：\nmid<br>⋅：\cdot<br>∘：\circ<br>∗：\ast<br>⨀：\bigodot<br>⨂：\bigotimes<br>⨁：\bigoplus<br>≤：\leq<br>≥：\geq<br>≠：\neq<br>≈：\approx<br>≡：\equiv<br>∑：\sum<br>∏：\prod<br>∐：\coprod</p><h4 id="集合运算符："><a href="#集合运算符：" class="headerlink" title="集合运算符："></a>集合运算符：</h4><p>∅：\emptyset<br>∈：\in<br>∉：\notin<br>⊂：\subset<br>⊃：\supset<br>⊆：\subseteq<br>⊇：\supseteq<br>⋂：\bigcap<br>⋃：\bigcup<br>⋁：\bigvee<br>⋀：\bigwedge<br>⨄：\biguplus<br>⨆：\bigsqcup</p><h4 id="对数运算符："><a href="#对数运算符：" class="headerlink" title="对数运算符："></a>对数运算符：</h4><p>log：\log<br>lg：\lg<br>ln：\ln</p><h4 id="三角运算符："><a href="#三角运算符：" class="headerlink" title="三角运算符："></a>三角运算符：</h4><p>⊥：\bot<br>∠：\angle<br>30∘：30^\circ<br>sin：\sin<br>cos：\cos<br>tan：\tan<br>cot：\cot<br>sec：\sec<br>csc：\csc</p><h4 id="微积分运算符："><a href="#微积分运算符：" class="headerlink" title="微积分运算符："></a>微积分运算符：</h4><p>′：\prime<br>∫：\int<br>∬：\iint<br>∭：\iiint<br>⨌：\iiiint<br>∮：\oint<br>lim：\lim<br>∞：\infty<br>∇：\nabla</p><h4 id="逻辑运算符："><a href="#逻辑运算符：" class="headerlink" title="逻辑运算符："></a>逻辑运算符：</h4><p>∵：\because<br>∴：\therefore<br>∀：\forall<br>∃：\exists<br>≠：\not=<br>≯：\not&gt;<br>⊄：\not\subset</p><h4 id="戴帽符号："><a href="#戴帽符号：" class="headerlink" title="戴帽符号："></a>戴帽符号：</h4><p>$\hat{y}$ ：\hat{y}<br>$\check{y} $：\check{y}<br>$\breve{y}$：\breve{y}</p><h4 id="连线符号："><a href="#连线符号：" class="headerlink" title="连线符号："></a>连线符号：</h4><p>$\overline{a+b+c+d}$ ：\overline{a+b+c+d} </p><p>$\underline{a+b+c+d} $ ：\underline{a+b+c+d} </p><h4 id="箭头符号："><a href="#箭头符号：" class="headerlink" title="箭头符号："></a>箭头符号：</h4><p>↑：\uparrow<br>↓：\downarrow<br>⇑：\Uparrow<br>⇓：\Downarrow<br>→：\rightarrow<br>←：\leftarrow<br>⇒：\Rightarrow<br>⇐：\Leftarrow<br>⟶：\longrightarrow<br>⟵：\longleftarrow<br>⟹：\Longrightarrow<br>⟸：\Longleftarrow</p><p>要输出字符　空格　#　$　%　&amp;　_　{　}　，用命令：　\空格　#　\$　\%　\&amp;　_　{　}</p><h3 id="如何进行字体转换"><a href="#如何进行字体转换" class="headerlink" title="如何进行字体转换"></a>如何进行字体转换</h3><p>要对公式的某一部分字符进行字体转换，可以用{\rm 需转换的部分字符}命令，其中\rm可以参照下表选择合适的字体。一般情况下，公式默认为意大利体。<br>\rm　　罗马体　　　　　　　\it　　意大利体<br>\bf　　黑体　　　　　　　　\cal 　花体<br>\sl　　倾斜体　　　　　　　\sf　　等线体<br>\mit 　数学斜体　　　　　　\tt　　打字机字体<br>\sc　　小体大写字母</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;转载于&lt;a href=&quot;https://www.zybuluo.com/knight/note/96093&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;@knight&lt;/a&gt;博客，感谢博主的分享。&lt;/p&gt;
&lt;/blockquot
      
    
    </summary>
    
      <category term="MathJax" scheme="http://yoursite.com/categories/MathJax/"/>
    
    
      <category term="LaTex" scheme="http://yoursite.com/tags/LaTex/"/>
    
      <category term="MathJax" scheme="http://yoursite.com/tags/MathJax/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客重建记</title>
    <link href="http://yoursite.com/2018/08/04/Hexo%E5%8D%9A%E5%AE%A2%E9%87%8D%E5%BB%BA%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/08/04/Hexo博客重建记/</id>
    <published>2018-08-04T15:29:38.000Z</published>
    <updated>2018-08-10T08:46:50.005Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>好记性是真的不如烂笔头！另外，自己也深刻觉得做事情多做10%十分重要，比如阅解决一个什么问题，不能懒，及时记录下来，下次遇到便能省不少事儿，而现实情况是每次遇到同一个问题还要重新折腾，很是难受；比如看书，及时整理记录下来，时而回顾，也能防止遗忘，节约不少功夫。<br>半年前兴趣突发用Hexo鼓捣了一个博客，结果之后就荒废了，再想用的时候发现什么都忘了，耽误很多时间，遂决定重建一下，并记录下来这个过程，一来以备自己随时查阅，二来可以给想建博客的人们一个参考。</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>在安装 Hexo 之前，需要确保检查电脑中已安装下列软件：</p><ul><li>Node.js</li><li>Git</li></ul><p>有关Git和Node.js的安装可以参考廖雪峰的<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137396287703354d8c6c01c904c7d9ff056ae23da865a000" target="_blank" rel="noopener">Git教程</a>和<a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434501245426ad4b91f2b880464ba876a8e3043fc8ef000" target="_blank" rel="noopener">JavaScript教程</a>。对于windows用户来说，推荐使用 Git Bash 进行操作，这是git for windows自带的一组程序。</p><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>接下来只需要运行下面一句命令即可完成 Hexo 的安装。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure></p><p>安装 Hexo 完成后，新建一个网站，执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init Hexo_Blog  # Hexo_Blog是博客所在文件夹名，可自行替换为你的文件夹</span><br><span class="line">$ cd Hexo_Blog</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure></p><h3 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h3><p>设置主题，这里我采用的是非常受欢迎的<a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">Next主题</a>，运行下面命令，直接克隆整个仓库。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd Hexo_Blog</span><br><span class="line">$ git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure></p><p>然后在<strong>站点配置文件</strong>中设置你的主题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure></p><p>接下来我们验证主题是否安装成功。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo s --debug</span><br></pre></td></tr></table></figure></p><p>此时使用浏览器访问 <a href="http://localhost:4000，检查是否成功。如果端口4000被占用，可使用" target="_blank" rel="noopener">http://localhost:4000，检查是否成功。如果端口4000被占用，可使用</a> -p 更换端口。</p><blockquote><p>在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。为了描述方便，在以下说明中，将前者称为 站点配置文件， 后者称为 主题配置文件。</p></blockquote><h3 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h3><h4 id="选择-Scheme"><a href="#选择-Scheme" class="headerlink" title="选择 Scheme"></a>选择 Scheme</h4><p>Scheme 是 NexT 提供的一种特性，不同Scheme有不同的外观。切换只需在<strong>主题配置文件</strong>中更改即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Schemes</span><br><span class="line">scheme: Muse</span><br><span class="line">#scheme: Mist</span><br><span class="line">#scheme: Pisces</span><br><span class="line">#scheme: Gemini</span><br></pre></td></tr></table></figure></p><h4 id="设置站点名，语言，作者昵称，站点描述"><a href="#设置站点名，语言，作者昵称，站点描述" class="headerlink" title="设置站点名，语言，作者昵称，站点描述"></a>设置站点名，语言，作者昵称，站点描述</h4><p>在<strong>站点配置文件</strong>进行更改，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Site</span><br><span class="line">title: shuang&apos;s blog</span><br><span class="line">subtitle:</span><br><span class="line">description: 滴水穿石，非一日之功</span><br><span class="line">keywords:</span><br><span class="line">author: cccshuang</span><br><span class="line">language: zh-Hans</span><br><span class="line">timezone:</span><br></pre></td></tr></table></figure></p><h4 id="设置头像"><a href="#设置头像" class="headerlink" title="设置头像"></a>设置头像</h4><p>将头像放置主题目录下的 source/images/ 目录下，在<strong>主题配置文件</strong>中配置为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">avatar: /images/avatar.gif</span><br></pre></td></tr></table></figure></p><h4 id="设置菜单"><a href="#设置菜单" class="headerlink" title="设置菜单"></a>设置菜单</h4><p>在<strong>主题配置文件</strong>中修改以下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home</span><br><span class="line">  #about: /about/ || user</span><br><span class="line">  tags: /tags/ || tags</span><br><span class="line">  categories: /categories/ || th</span><br><span class="line">  archives: /archives/ || archive</span><br></pre></td></tr></table></figure></p><p>其中分类、标签云、关于等页面需要自己添加，输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page &quot;categories&quot; #新建页面</span><br></pre></td></tr></table></figure></p><p>之后在站点目录下的source文件夹下，会新增一个categories的文件夹，里面有一个index.md文件，编辑如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: 分类</span><br><span class="line">date: 2018-08-04 15:44:40</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">comments: false</span><br></pre></td></tr></table></figure></p><p>comments设置为false是打开分类页面，不显示评论插件。<br>tags, about页面的创建相似，如出现中文乱码，可尝试把创建的md文件更改为UTF-8编码。</p><h4 id="设置首页列表是否显示阅读更多"><a href="#设置首页列表是否显示阅读更多" class="headerlink" title="设置首页列表是否显示阅读更多"></a>设置首页列表是否显示阅读更多</h4><p>在<strong>主题配置文件</strong>中修改以下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto_excerpt:</span><br><span class="line">  enable: true</span><br><span class="line">  length: 150</span><br></pre></td></tr></table></figure></p><h4 id="添加RSS"><a href="#添加RSS" class="headerlink" title="添加RSS"></a>添加RSS</h4><p>首先安装 hexo-generator-feed插件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save hexo-generator-feed</span><br></pre></td></tr></table></figure></p><p>修改站点配置文件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">feed: # RSS</span><br><span class="line">  type: atom</span><br><span class="line">  path: atom.xml</span><br><span class="line">  limit: 0</span><br><span class="line"></span><br><span class="line">plugins: hexo-generate-feed</span><br></pre></td></tr></table></figure></p><p>修改主题配置文件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rss: /atom.xml</span><br></pre></td></tr></table></figure></p><h4 id="添加侧边栏社交链接"><a href="#添加侧边栏社交链接" class="headerlink" title="添加侧边栏社交链接"></a>添加侧边栏社交链接</h4><p>修改主题配置文件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">social:</span><br><span class="line">  GitHub: your github url</span><br><span class="line">  ZhiHu: your zhihu url</span><br></pre></td></tr></table></figure></p><h4 id="字数统计"><a href="#字数统计" class="headerlink" title="字数统计"></a>字数统计</h4><p>统计文章的字数以及大致分析出阅读时间。修改主题配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">post_wordcount:</span><br><span class="line">  item_text: true</span><br><span class="line">  wordcount: true</span><br><span class="line">  min2read: true</span><br><span class="line">  totalcount: true</span><br><span class="line">  separated_meta: ture</span><br></pre></td></tr></table></figure></p><p>并安装插件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-wordcount --save</span><br></pre></td></tr></table></figure></p><h4 id="背景动画"><a href="#背景动画" class="headerlink" title="背景动画"></a>背景动画</h4><p>将主题配置文件下面其中一项改为true即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Canvas-nest</span><br><span class="line">canvas_nest: true</span><br><span class="line"># three_waves</span><br><span class="line">three_waves: false</span><br><span class="line"># canvas_lines</span><br><span class="line">canvas_lines: false</span><br><span class="line"># canvas_sphere</span><br><span class="line">canvas_sphere: false</span><br></pre></td></tr></table></figure></p><h4 id="添加自动打开编辑器脚本"><a href="#添加自动打开编辑器脚本" class="headerlink" title="添加自动打开编辑器脚本"></a>添加自动打开编辑器脚本</h4><p>在 博客根目录/scripts/ 下新建 AutoOpenEditor.js 文件（取其他名字也可以，不影响）（如果没有 scripts 目录则新建），并粘贴以下代码，保存。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let spawn = require(&apos;hexo-util/lib/spawn&apos;);</span><br><span class="line"></span><br><span class="line">hexo.on(&apos;new&apos;, (data) =&gt; &#123;</span><br><span class="line">  spawn(&apos;code&apos;, [hexo.base_dir, data.path]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>这样，在你每次 hexo new 的时候，脚本就会自动帮你打开 VS Code 并切换到博客根目录顺带打开新建的 .md 文件啦。<br>参考博客 <a href="https://leaferx.online/2018/03/17/hexo-auto-open-vscode/" target="_blank" rel="noopener">HEXO小技巧在 hexo new 的时候自动用 VS Code 打开新建文章</a></p><h3 id="第三方服务"><a href="#第三方服务" class="headerlink" title="第三方服务"></a>第三方服务</h3><h4 id="阅读次数统计（LeanCloud）"><a href="#阅读次数统计（LeanCloud）" class="headerlink" title="阅读次数统计（LeanCloud）"></a>阅读次数统计（LeanCloud）</h4><p>可参考这个博客 <a href="https://notes.wanghao.work/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html#%E9%85%8D%E7%BD%AELeanCloud" target="_blank" rel="noopener">为NexT主题添加文章阅读量统计功能</a></p><h4 id="分享文章功能"><a href="#分享文章功能" class="headerlink" title="分享文章功能"></a>分享文章功能</h4><p>使用<a href="https://www.addthis.com" target="_blank" rel="noopener">AddThis</a>，定义自己的样式，如可以通过微信，微博，qq等进行分享。然后在Profile Settings的General里复制ID，修改主题配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_this_id: &#123;your AddThis ID&#125;</span><br></pre></td></tr></table></figure></p><p>更多设置，可以参考博客<a href="https://www.jianshu.com/p/1f8107a8778c" target="_blank" rel="noopener">hexo搭建个人博客–NexT主题优化</a></p><h4 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h4><p>修改主题配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># MathJax Support</span><br><span class="line">mathjax:</span><br><span class="line">  enable: true</span><br><span class="line">  per_page: true</span><br><span class="line">  cdn: //cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML</span><br></pre></td></tr></table></figure></p><p>在写博客时，如果博文带有公式，头部增加一项mathjax，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: math</span><br><span class="line">date: 2018-08-04 23:12:07</span><br><span class="line">tags:</span><br><span class="line">mathjax: true</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><h3 id="部署到github"><a href="#部署到github" class="headerlink" title="部署到github"></a>部署到github</h3><p>登录github，创建一个repo，名称为 “yourname.github.io”, 其中yourname是你的github名称。<br>在<strong>站点配置文件</strong>进行更改，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:yourname/yourname.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></p><p>然后安装一个插件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p><p>执行命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo g</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure></p><p>或<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo d -g #生成并上传</span><br></pre></td></tr></table></figure></p><p>即可将你写好的文章部署到github服务器上，打开浏览器，输入<a href="http://yourgithubname.github.io" target="_blank" rel="noopener">http://yourgithubname.github.io</a> 检测是否成功。</p><p>如果出现如下类似的错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">error: failed to execute prompt script (exit code 1)</span><br><span class="line">fatal: could not read Username for &apos;https://github.com&apos;: Invalid argument</span><br><span class="line"></span><br><span class="line">    at ChildProcess.&lt;anonymous&gt; (H:\Hexo_Blog\node_modules\hexo-util\lib\spawn.js:37:17)</span><br><span class="line">    at emitTwo (events.js:126:13)</span><br><span class="line">    at ChildProcess.emit (events.js:214:7)</span><br><span class="line">    at ChildProcess.cp.emit (H:\Hexo_Blog\node_modules\cross-spawn\lib\enoent.js:40:29)</span><br><span class="line">    at maybeClose (internal/child_process.js:925:16)</span><br><span class="line">    at Process.ChildProcess._handle.onexit (internal/child_process.js:209:5)</span><br></pre></td></tr></table></figure></p><p>可以尝试重新<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137396287703354d8c6c01c904c7d9ff056ae23da865a000" target="_blank" rel="noopener">配置github账户信息</a>和<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001374385852170d9c7adf13c30429b9660d0eb689dd43a000" target="_blank" rel="noopener">配置SSH</a>。</p><h3 id="写博客"><a href="#写博客" class="headerlink" title="写博客"></a>写博客</h3><p>hexo根目录，执行命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new &apos;first blog&apos;</span><br></pre></td></tr></table></figure></p><p>hexo会在\source_posts下生成相关md文件，打开便可开始写博客了。博客格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: MongoDB学习笔记</span><br><span class="line">date: 2018-01-17 19:40:37</span><br><span class="line">categories:</span><br><span class="line">- Database</span><br><span class="line">tags:</span><br><span class="line">- MongoDB</span><br><span class="line">- NoSQL</span><br><span class="line">---</span><br><span class="line">正文blabla</span><br></pre></td></tr></table></figure></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>卸载hexo<br><code>$ npm uninstall hexo-cli -g</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;好记性是真的不如烂笔头！另外，自己也深刻觉得做事情多做10%十分重要，比如阅解决一个什么问题，不能懒，及时记录下来，下次遇到便能省不少事儿，
      
    
    </summary>
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>测试公式</title>
    <link href="http://yoursite.com/2018/08/04/%E6%B5%8B%E8%AF%95%E5%85%AC%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/08/04/测试公式/</id>
    <published>2018-08-04T15:12:07.000Z</published>
    <updated>2018-08-10T09:16:59.356Z</updated>
    
    <content type="html"><![CDATA[<p>$f(x_1) = sin(x_1)^2$</p><p>$$f(x)=<br>\begin{cases}<br>0&amp; \text{x=0}\\<br>1&amp; \text{x!=0}<br>\end{cases}$$</p><p>$$<br>\sum_{i=0}^N\int_{a}^{b}g(t,i)\text{d}t<br>$$</p><p>$$\begin{bmatrix}<br>{a_{11}}&amp;{a_{12}}&amp;{\cdots}&amp;{a_{1n}}\\<br>{a_{21}}&amp;{a_{22}}&amp;{\cdots}&amp;{a_{2n}}\\<br>{\vdots}&amp;{\vdots}&amp;{\ddots}&amp;{\vdots}\\<br>{a_{m1}}&amp;{a_{m2}}&amp;{\cdots}&amp;{a_{mn}}\\<br>\end{bmatrix}$$</p><p>$$\begin{cases}<br>a_1x+b_1y+c_1z=d_1\\<br>a_2x+b_2y+c_2z=d_2\\<br>a_3x+b_3y+c_3z=d_3\\<br>\end{cases}<br>$$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;$f(x_1) = sin(x_1)^2$&lt;/p&gt;
&lt;p&gt;$$f(x)=&lt;br&gt;\begin{cases}&lt;br&gt;0&amp;amp; \text{x=0}\\&lt;br&gt;1&amp;amp; \text{x!=0}&lt;br&gt;\end{cases}$$&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;\sum_{i=
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MongoDB学习笔记</title>
    <link href="http://yoursite.com/2018/01/17/2018-01-17-MongoDB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/01/17/2018-01-17-MongoDB学习笔记/</id>
    <published>2018-01-17T11:40:37.000Z</published>
    <updated>2018-01-17T12:25:16.463Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h3><h3 id="Windows上安装方法："><a href="#Windows上安装方法：" class="headerlink" title="Windows上安装方法："></a>Windows上安装方法：</h3><ol><li>下载，安装，可以从customer自定义安装路径后，例如我设置的安装路径为”F:\MongoDB\”，一直Next直到安装结束。</li><li>配置<ul><li>将安装路径下的bin目录添加到环境变量PATH中，例如我的是”F:\MongoDB\bin”；</li><li>配置MongoDB的存储路径，例如我配置的是”F:\MongoDB\data\db”，就是在”F:\MongoDB\”这个文件夹下新建”data\db”这种目录结构；</li><li>将MongoDB注册为服务，以方便日后的使用：<ul><li>打开cmd命令行，输入（将logpath 和dbpath 改成自己的）：<br><code>mongod --logpath &quot;F:\MongoDB\logs.log&quot; --dbpath &quot;F:\MongoDB\data\db&quot; --install</code><ul><li>注册完成，便可通过输入：<br><code>net start mongodb</code><br>便可启动服务。</li></ul></li></ul></li><li>在命令行输入<code>mongo</code>之后便可以打开shell对MongoDB进行操作啦~</li></ul></li></ol><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><table><thead><tr><th>SQL概念</th><th>MongoDB概念</th><th>说明</th></tr></thead><tbody><tr><td>database</td><td>database</td><td>数据库</td></tr><tr><td>table</td><td>collection</td><td>数据库表/集合</td></tr><tr><td>row</td><td>document</td><td>数据行/文档</td></tr><tr><td>column</td><td>field</td><td>数据字段列/域</td></tr></tbody></table><p>文档：文档是有序的，大小写敏感的。键不能包含”\0”，这个字符用于标记键的结尾；”.”、”$”、”_”保留，建议不要使用在键中。文档的数据结构和JSON基本一样，所有存在集合中的数据都是BSON格式。</p><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><ul><li>创建/删除数据库<br><code>show dbs</code>查看所有数据库<br><code>use DATABASE_NAME</code>创建数据库，若不存在则新建，否则进入此数据库<br><code>db.dropDatabase()</code>删除当前数据库</li><li>集合<br><code>show collections</code>查看所有集合<br><code>db.createCollection(name, options)</code> 创建集合。options参数是可选的，如autoIndexId 参数，如果为true，则在_id字段上自动创建索引，默认值为false。<br>例子：<code>db.createCollection(&quot;mytest&quot;, { autoIndexId : true})</code><br><code>db.COLLECTION_NAME.drop()</code> 删除集合</li><li><p>插入文档<br>insert()或save()方法<br><code>db.COLLECTION_NAME.insert(document)</code><br>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> db.mytest.insert(&#123;</span><br><span class="line">name: &apos;Bob&apos;,</span><br><span class="line">score: 100</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>查询文档<br><code>db.COLLECTION_NAME.find()</code> 相当于SQL中的select * from tabe<br><code>db.COLLECTION_NAME.find().pretty()</code>以易读方式展现<br>条件语句和操作符：</p></li></ul><table><thead><tr><th>操作</th><th>格式</th><th>示例</th><th>说明</th></tr></thead><tbody><tr><td>等于</td><td><code>{&lt;key&gt;:&lt;value&gt;}</code></td><td><code>db.mytest.find({&quot;score&quot;:100})</code></td><td>从mytest集合中找到score等于100的文档</td></tr><tr><td>小于</td><td><code>{&lt;key&gt;:{$lt:&lt;value&gt;}}</code></td><td><code>db.mytest.find({&quot;score&quot;:{$lt:100}})</code></td><td>从mytest集合中找到score小于100的文档</td></tr><tr><td>小于或等于</td><td><code>{&lt;key&gt;:{$lte:&lt;value&gt;}}</code></td><td><code>db.mytest.find({&quot;score&quot;:{$lte:100}})</code></td><td>从mytest集合中找到score小于或等于100的文档</td></tr><tr><td>大于</td><td><code>{&lt;key&gt;:{$gt:&lt;value&gt;}}</code></td><td><code>db.mytest.find({&quot;score&quot;:{$gt:100}})</code></td><td>从mytest集合中找到score大于100的文档</td></tr><tr><td>大于或等于</td><td><code>{&lt;key&gt;:{$gte:&lt;value&gt;}}</code></td><td><code>db.mytest.find({&quot;score&quot;:{$gte:100}})</code></td><td>从mytest集合中找到score大于或等于100的文档</td></tr><tr><td>不等于</td><td><code>{&lt;key&gt;:{$ne:&lt;value&gt;}}</code></td><td><code>db.mytest.find({&quot;score&quot;:{$ne:100}})</code></td><td>从mytest集合中找到score不等于100的文档</td></tr></tbody></table><p> 条件组合：<br>  AND：以逗号隔开<br><code>db.mytest.find({&quot;score&quot;:{$gte:100}, &quot;name&quot;:&quot;Bob&quot;})</code><br> OR:使用关键字”$or”<br><code>db.mytest.find({$or:[{&quot;score&quot;:{$gte:100}},{&quot;name&quot;: &quot;Tom&quot;}]}).pretty()</code></p><ul><li><p>更新文档</p><ul><li>update()方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> db.COLLECTION_NAME.update(</span><br><span class="line">   &lt;query&gt;,  update的查询条件</span><br><span class="line">   &lt;update&gt;,  update的更新对象等，类似sql update查询内set后面的</span><br><span class="line">   &#123;</span><br><span class="line">     upsert: &lt;boolean&gt;,  可选，不存在update的记录，是否新插入，默认是false，不插入</span><br><span class="line">     multi: &lt;boolean&gt;, 可选，默认是false,只更新找到的第一条记录</span><br><span class="line">     writeConcern: &lt;document&gt; 可选，抛出异常的级别</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul><p>例子：将名字为Bob的记录更改为Jack，更新多条<br><code>db.mytest.update({&#39;name&#39;:&#39;Bob&#39;},{$set:{&#39;name&#39;:&#39;Jack&#39;}},{multi:true})</code></p><ul><li>save()方法：通过传入的文档来替换已有文档<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   db.COLLECTION_NAME.save(</span><br><span class="line">   &lt;document&gt;, 文档数据</span><br><span class="line">   &#123;</span><br><span class="line">     writeConcern: &lt;document&gt; 可选，抛出异常的级别</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>例子：替换 _id 为 56064f89ade2f21f36b04236 的文档数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.mytest.save(&#123;</span><br><span class="line">    &quot;_id&quot; : ObjectId(&quot;5a5f103d1fa359a981d5ec90&quot;),</span><br><span class="line">    &quot;name&quot; : &quot;Marry&quot;,</span><br><span class="line">    &quot;score&quot; :  100</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><ul><li>删除文档<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.COLLECTION_NAME.remove(</span><br><span class="line">   &lt;query&gt;, 可选，删除的文档的条件。若无，则删除全部文档</span><br><span class="line">   &#123;</span><br><span class="line">     justOne: &lt;boolean&gt;, 可选，设为 true 或 1，则只删除一个文档</span><br><span class="line">     writeConcern: &lt;document&gt; 可选，抛出异常的级别</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul><p>例子：删除名字为Tom的文档<br><code>db.mytest.remove({&quot;name&quot;:&quot;Marry&quot;})</code></p><p>练习：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">use mydb  #创建数据库</span><br><span class="line">show dbs  #查询所有数据库</span><br><span class="line">db.createCollection(&quot;mytest&quot;, &#123; autoIndexId : true&#125;) #创建集合mytest</span><br><span class="line">show collections  #查询所有集合</span><br><span class="line">#插入数据</span><br><span class="line">db.mytest.insert(&#123;</span><br><span class="line">      name: &apos;Bob&apos;,</span><br><span class="line">      score: 100</span><br><span class="line">      &#125;)</span><br><span class="line">db.mytest.insert(&#123;</span><br><span class="line">      name: &apos;Tom&apos;,</span><br><span class="line">      score: 96</span><br><span class="line">      &#125;)</span><br><span class="line">db.mytest.find(&#123;&quot;score&quot;:100&#125;) #查询mytest中score为100的记录</span><br><span class="line">db.mytest.find(&#123;&quot;score&quot;:&#123;$lt:100&#125;&#125;)</span><br><span class="line">db.mytest.find(&#123;$or:[&#123;&quot;score&quot;:&#123;$gte:100&#125;&#125;,&#123;&quot;name&quot;: &quot;Tom&quot;&#125;]&#125;).pretty()</span><br><span class="line">db.mytest.update(&#123;&apos;name&apos;:&apos;Bob&apos;&#125;,&#123;$set:&#123;&apos;name&apos;:&apos;Jack&apos;&#125;&#125;,&#123;multi:true&#125;)</span><br><span class="line">db.mytest.find() #查询mytest中所有记录</span><br><span class="line">#将_id为5a5f103d1fa359a981d5ec90的数据替换</span><br><span class="line">db.mytest.save(&#123;</span><br><span class="line">    &quot;_id&quot; : ObjectId(&quot;5a5f103d1fa359a981d5ec90&quot;),</span><br><span class="line">    &quot;name&quot; : &quot;Marry&quot;,</span><br><span class="line">    &quot;score&quot; :  100</span><br><span class="line">&#125;)</span><br><span class="line">db.mytest.remove(&#123;&quot;name&quot;:&quot;Marry&quot;&#125;)  #删除mytest中名字为Marry的记录</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;MongoDB&quot;&gt;&lt;a href=&quot;#MongoDB&quot; class=&quot;headerlink&quot; title=&quot;MongoDB&quot;&gt;&lt;/a&gt;MongoDB&lt;/h3&gt;&lt;h3 id=&quot;Windows上安装方法：&quot;&gt;&lt;a href=&quot;#Windows上安装方法：&quot; class
      
    
    </summary>
    
      <category term="Database" scheme="http://yoursite.com/categories/Database/"/>
    
    
      <category term="MongoDB" scheme="http://yoursite.com/tags/MongoDB/"/>
    
      <category term="NoSQL" scheme="http://yoursite.com/tags/NoSQL/"/>
    
  </entry>
  
  <entry>
    <title>对西安市计算机相关职位情况的分析</title>
    <link href="http://yoursite.com/2018/01/14/2018-01-14-%E5%AF%B9%E8%A5%BF%E5%AE%89%E5%B8%82%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9B%B8%E5%85%B3%E8%81%8C%E4%BD%8D%E6%83%85%E5%86%B5%E7%9A%84%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2018/01/14/2018-01-14-对西安市计算机相关职位情况的分析/</id>
    <published>2018-01-14T06:55:05.000Z</published>
    <updated>2018-01-14T07:00:44.511Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对西安市计算机相关职位情况的分析"><a href="#对西安市计算机相关职位情况的分析" class="headerlink" title="对西安市计算机相关职位情况的分析"></a>对西安市计算机相关职位情况的分析</h1><h2 id="报告主题"><a href="#报告主题" class="headerlink" title="报告主题"></a>报告主题</h2><p>本报告主要有以下几个目的：</p><ol><li>分析西安市计算机相关职位的需求情况</li><li>分析西安市计算机相关职位的薪酬情况</li><li>分析西安市计算机相关职位的招聘要求</li><li>为广大意向从事计算机行业人群的就业提供借鉴和指导</li></ol><h2 id="数据来源"><a href="#数据来源" class="headerlink" title="数据来源"></a>数据来源</h2><p>本报告对<code>智联招聘</code>网站进行爬虫，主要采集以下几方面的数据,爬虫代码见作业中<code>代码</code>部分。</p><ul><li>Java相关职位</li><li>C++相关职位</li><li>Python相关职位</li><li>C#相关职位</li><li>Ruby相关职位</li><li>PHP相关职位</li><li>.NET相关职位</li><li>Swift相关职位</li><li>Go相关职位</li><li>Scala相关职位</li></ul><h2 id="分析思路"><a href="#分析思路" class="headerlink" title="分析思路"></a>分析思路</h2><p>分析思路主要包含以下几步。</p><ul><li>数据读取</li><li>数据整理</li><li>分析职位数量情况</li><li>分析职位月薪情况</li><li>分析招聘岗位要求</li></ul><h2 id="计算过程"><a href="#计算过程" class="headerlink" title="计算过程"></a>计算过程</h2><p>以下是数据分析和数据挖掘过程</p><h3 id="数据读取"><a href="#数据读取" class="headerlink" title="数据读取"></a>数据读取</h3><p>将通过爬虫爬取的数据通过Python按行读取，去除不符合规则的数据，进而转换为字典，存在列表里面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">def read_data():</span><br><span class="line">    lists=[]</span><br><span class="line">    try:</span><br><span class="line">        f = open(&apos;r.txt&apos;,&apos;r&apos;,encoding=&apos;utf-8&apos;)</span><br><span class="line">        tmp_list = f.readline()</span><br><span class="line">        lists.append(tmp_list)</span><br><span class="line">        while tmp_list:</span><br><span class="line">            tmp_list = f.readline()</span><br><span class="line">            lists.append(tmp_list)</span><br><span class="line">    except:</span><br><span class="line">        print(&apos;error:&apos;,tmp_list)</span><br><span class="line">    finally:</span><br><span class="line">        f.close()     </span><br><span class="line">    datas = []  </span><br><span class="line">    for item in lists:</span><br><span class="line">        if(not item.startswith(&apos;&#123;\&apos;&apos;)):</span><br><span class="line">            continue       </span><br><span class="line">        dic = eval(item)</span><br><span class="line">        datas.append(dic)</span><br><span class="line">    return datas</span><br></pre></td></tr></table></figure></p><h3 id="数据整理"><a href="#数据整理" class="headerlink" title="数据整理"></a>数据整理</h3><ol><li><p>使用pandas包，将数据组织成DataFrame形式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(datas)</span><br></pre></td></tr></table></figure></li><li><p>将日期格式规范化，并对数据进行筛选，对月薪的数据进行筛选，选取格式为“XXXX-XXXX”的信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(datas)</span><br><span class="line">df[&apos;save_date&apos;] = pd.to_datetime(df[&apos;save_date&apos;])</span><br><span class="line">df_clean = df[[&apos;position_name&apos;,</span><br><span class="line">       &apos;feedback&apos;,</span><br><span class="line">       &apos;company_name&apos;,</span><br><span class="line">       &apos;salary&apos;,</span><br><span class="line">       &apos;place&apos;,</span><br><span class="line">       &apos;time&apos;,</span><br><span class="line">       &apos;brief&apos;,</span><br><span class="line">       &apos;link&apos;,</span><br><span class="line">       &apos;save_date&apos;,</span><br><span class="line">       &apos;keyword&apos;]]</span><br><span class="line">df_clean = df_clean[df_clean[&apos;salary&apos;].str.contains(&apos;\d+-\d+&apos;, regex=True)]</span><br></pre></td></tr></table></figure></li><li><p>根据链接作为标志判断爬取的数据是否有重复值，并进行去重工作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_clean_concat = df_clean_concat.drop_duplicates([&apos;link&apos;])</span><br></pre></td></tr></table></figure></li></ol><h3 id="分析职位数量情况"><a href="#分析职位数量情况" class="headerlink" title="分析职位数量情况"></a>分析职位数量情况</h3><p>对西安市计算机行业不同职位数量的分布情况进行分析。</p><ol><li><p>首先以不同职位作为关键词进行分析，并按职位数量进行排序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">df_key_main = df_city[df_city[&apos;keyword&apos;].isin(KEYWORDS)]</span><br><span class="line">df_key_main_count = df_key_main.groupby(&apos;keyword&apos;)[&apos;position_name&apos;,&apos;company_name&apos;].count()</span><br><span class="line">df_key_main_count[&apos;company_name&apos;] = df_key_main_count[&apos;company_name&apos;]/(df_key_main_count[&apos;company_name&apos;].sum())</span><br><span class="line">df_key_main_count.columns = [&apos;number&apos;, &apos;percentage&apos;]</span><br><span class="line">df_key_main_count.sort_values(by=&apos;number&apos;, ascending=False, inplace=True)</span><br></pre></td></tr></table></figure></li><li><p>对西安市计算机行业不同职位数量的情况进行分析，以饼图的形式呈现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">label = df_key_main_count[&apos;label&apos;]</span><br><span class="line">sizes = df_key_main_count[&apos;number&apos;]</span><br><span class="line"># 设置绘图区域大小</span><br><span class="line">fig, axes = plt.subplots(figsize=(10,6),ncols=2)</span><br><span class="line">ax1, ax2 = axes.ravel()</span><br><span class="line">colors  = [&quot;blue&quot;,&quot;red&quot;,&quot;coral&quot;,&quot;green&quot;,&quot;yellow&quot;,&quot;orange&quot;] </span><br><span class="line">patches, texts = ax1.pie(sizes,labels=None, shadow=False, startangle=0, colors=colors)</span><br><span class="line">ax1.axis(&apos;equal&apos;)  </span><br><span class="line">ax1.set_title(&apos;职位数量分布&apos;, loc=&apos;center&apos;)</span><br><span class="line"># ax2 只显示图例（legend）</span><br><span class="line">ax2.axis(&apos;off&apos;)</span><br><span class="line">ax2.legend(patches, label, loc=&apos;center left&apos;, fontsize=9)</span><br><span class="line">plt.savefig(&apos;job_pie.jpg&apos;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></li></ol><p>所得饼图如下所示：<br><img src="/images/job_pie.jpg" alt="Alt text"></p><p>观察图表，可以看到，传统的Java和C++开发职位占据所有职位数量的半壁江山，此外，.NET，PHP，Python也占据了一部分，而像Scala，Swift等新出现的语言相关的职位则几乎没有。所以，像Java，C++在西安的计算机相关职位招聘中还是属于主流。</p><h3 id="分析职位月薪情况"><a href="#分析职位月薪情况" class="headerlink" title="分析职位月薪情况"></a>分析职位月薪情况</h3><p>对西安市的职位月薪情况进行分析。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">df_salary_adjust = df_clean_concat[df_clean_concat[&apos;salary_min&apos;]&lt;=20000]</span><br><span class="line"> fig, (ax1, ax2) = plt.subplots(figsize=(10,8), nrows=2)</span><br><span class="line"> x_pos = list(range(df_salary_adjust.shape[0]))</span><br><span class="line"> y1 = df_salary_adjust[&apos;salary_min&apos;]</span><br><span class="line"> ax1.plot(x_pos, y1)</span><br><span class="line"> ax1.set_title(&apos;西安计算机相关职位月薪趋势图&apos;, size=14)</span><br><span class="line"> ax1.set_xticklabels(&apos;&apos;)</span><br><span class="line"> ax1.set_ylabel(&apos;最低月薪(RMB)&apos;)</span><br><span class="line"> bins = [3000,6000, 9000, 12000, 15000, 18000, 21000]</span><br><span class="line"> counts, bins, patches = ax2.hist(y1, bins, normed=1, histtype=&apos;bar&apos;, facecolor=&apos;g&apos;, rwidth=0.8)</span><br><span class="line"> ax2.set_title(&apos;西安计算机相关职位月薪直方图&apos;, size=14)</span><br><span class="line"> ax2.set_yticklabels(&apos;&apos;)</span><br><span class="line"> ax2.set_xticks(bins) </span><br><span class="line"> ax2.set_xticklabels(bins, rotation=-90)</span><br><span class="line"> # Label the raw counts and the percentages below the x-axis...</span><br><span class="line"> bin_centers = 0.5 * np.diff(bins) + bins[:-1]</span><br><span class="line"> for count, x in zip(counts, bin_centers):</span><br><span class="line">     percent = &apos;%0.0f%%&apos; % (100 * float(count) / counts.sum())</span><br><span class="line">     ax2.annotate(percent, xy=(x, 0), xycoords=(&apos;data&apos;, &apos;axes fraction&apos;),</span><br><span class="line">                 xytext=(0, -40), textcoords=&apos;offset points&apos;, va=&apos;top&apos;, ha=&apos;center&apos;, rotation=-90, color=&apos;b&apos;, size=14)</span><br><span class="line"> fig.savefig(&apos;salary_inXian.jpg&apos;)</span><br><span class="line"> fig.show()</span><br></pre></td></tr></table></figure></p><p>所得结果如下所示：<br><img src="/images/salary_inXian.jpg" alt="Alt text"></p><p>观察图表，可以看到，西安市计算机相关职位月薪在3000~12000人民币占据了绝大部分，也有一小部分月薪达到了12000以上，但几乎没有超过20000的。这个月薪水平在西安可以基本达到小康水平。</p><h3 id="分析招聘岗位要求"><a href="#分析招聘岗位要求" class="headerlink" title="分析招聘岗位要求"></a>分析招聘岗位要求</h3><p>对西安市计算机相关职位招聘岗位要求描述进行词云图分析<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">brief_list = list(df_clean_concat[&apos;brief&apos;])</span><br><span class="line">brief_str = &apos;&apos;.join(brief_list)</span><br><span class="line"># 首先使用 jieba 中文分词工具进行分词</span><br><span class="line">wordlist = jieba.cut(brief_str, cut_all=False)      </span><br><span class="line"># cut_all, True为全模式，False为精确模式</span><br><span class="line">wordlist_space_split = &apos; &apos;.join(wordlist)</span><br><span class="line"></span><br><span class="line">my_wordcloud = WordCloud( max_words=100, font_path=&quot;simhei.ttf&quot;,background_color=&quot;white&quot;,</span><br><span class="line">                     max_font_size=300, random_state=42).generate(wordlist_space_split)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.imshow(my_wordcloud)            # 以图片的形式显示词云</span><br><span class="line">plt.axis(&apos;off&apos;)                     # 关闭坐标轴</span><br><span class="line">plt.show()</span><br><span class="line">my_wordcloud.to_file(os.path.join( &apos;brief_cloud.png&apos;))</span><br></pre></td></tr></table></figure></p><p>所得结果如下所示：</p><p><img src="/images/brief_cloud.png" alt="Alt text"></p><p>观察图表，可以看到企业在进行招聘时，看重具有相关的开发经验，比较青睐相关专业的人员，学历也占据了相对来说比较重要的地位，另外，也希望应聘人员具有团队合作的能力，具有较好的学习能力。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>本分析报告结论如下：</p><ul><li>Java，C++等开发岗位在西安的计算机相关职位招聘中属于主流，需求较多。</li><li>西安市计算机相关职位月薪大多在3000~12000人民币，在西安可以基本达到小康水平。</li><li>企业希望应聘人员具有相关的开发经验，比较青睐相关专业的人员，学历也占据了相对来说比较重要的地位。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;对西安市计算机相关职位情况的分析&quot;&gt;&lt;a href=&quot;#对西安市计算机相关职位情况的分析&quot; class=&quot;headerlink&quot; title=&quot;对西安市计算机相关职位情况的分析&quot;&gt;&lt;/a&gt;对西安市计算机相关职位情况的分析&lt;/h1&gt;&lt;h2 id=&quot;报告主题&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="Data mining" scheme="http://yoursite.com/categories/Data-mining/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="data" scheme="http://yoursite.com/tags/data/"/>
    
  </entry>
  
</feed>
